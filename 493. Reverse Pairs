https://leetcode.com/problems/reverse-pairs/description/

1. binary indexed tree(BIT)
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        int res = 0;
        vector<int> copy(nums);
        vector<int> bit(copy.size() + 1, 0);
        
        sort(copy.begin(), copy.end());
        
        for (int i = 0; i < nums.size(); i++) {
            res += search(bit, index(copy, nums[i] * 2L + 1));
            insert(bit, index(copy, nums[i]));
        }
        
        return res;
    }
    
private:
    int search(vector<int> &bit, int i) {
        int sum = 0;
        while (i < bit.size()) {
            sum += bit[i];
            i += i & (-i);
        }
        
        return sum;
    }
    
    void insert(vector<int> &bit, int i) {
        while (i > 0) {
            bit[i]++;
            i -= i & (-i);
        }
    }
    
    int index(vector<int> &arr, long long val) {
        int mid, l = 0, r = arr.size() - 1;
        
        while (l <= r) {
            mid = (l + r) >> 1;
            if (val <= arr[mid])
                r = mid - 1;
            else
                l = mid + 1;
        }
        
        return l + 1;       // this will return index of the first element not less than the assigned value, shifted up by 1 for BIT
    }
};

comment:
1. Maintain a BIT to record the number of elements no less than some value. For every element in BIT, the number is in fact the sum of
   elements positioned right to the current element in the current sorted array(imagine that the array is dynamic and elements continously inserted within
   that) including element itself.
2. Insertion would change the records in BIT, and searching would find the number of elements greater than twice of next element.
3. The principle behind that is sequential recurrence.

2. 
